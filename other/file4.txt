Когда я в первый раз запустил эту программу я был ошарашен результатами, я был уверен на 100% что увижу в консоли противоположный результат. Результат выполнения скрипта на Python 3.11.5:
Counter: expected val: 10000000, actual val: 10000000
CPython неведомым способом смог обеспечить атомарность небезопасной по умолчанию операции increment.
Как он это сделал? Давайте разбираться.
Проверяем на других версиях Python
Перед тем как погружаться в детали реализации стандартной библиотеки и внутренностей рантайма я решил проверить поведение программы на других версиях языка. В этом мне здорово помогла утилита pyenv
Скрипт автоматизирующий выполнение программы на разных версиях Python
#!/bin/bash
versions=(3.7 3.8 3.9 3.10 3.11)
for version in ${versions[*]}
do
  pyenv shell $version
  python3 --version
  python3 main.py
  echo '\n'
done
Результаты:
Python 3.7.17
Counter: expected val: 10000000, actual val: 4198551

Python 3.8.18
Counter: expected val: 10000000, actual val: 4999351

Python 3.9.18
Counter: expected val: 10000000, actual val: 3551269

Python 3.10.13
Counter: expected val: 10000000, actual val: 10000000

Python 3.11.5
Counter: expected val: 10000000, actual val: 10000000
Почему в одних версиях Python значение счетчика совпадает c ожидаемым а в других нет? Всему виной состояние гонки.
Состояние гонки на примере операции increment
Почему с нашим счетчиком возникает операция гонки? Всё дело в том что операция increment состоит из нескольких шагов:
прочитать значение (currVal = self.val)
увеличить (newVal =currVal + 1)
записать новое значение (self.val = newVal)
И переключение контекста между потоками может произойти после шага 1 или шага 2 , что приведет к тому что поток перед выполнением шага 3 будет иметь в своем распоряжении невалидные данные.
